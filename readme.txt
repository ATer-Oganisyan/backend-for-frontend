Описание архитектуры

Система состоит из 3-х сервисов и 1-ого ингреса.
1) user-crud - сервис, отвечающий за CRUD операции в БД. В нем нет никакой бизнес-логики, кроме как работа с БД. По сути это абстракция над БД.
2) session-service - сервис, аутентифицирющий и авторизующий пользователя. Выдает токен по логину и паролю, разлогинивает пользователя и возвращает идентификатор и роль пользователя по токену. Токен прописывается в куки.
3) profile-service - сервис, ответственный за работу с пользователями. Через него можно создавать, редактировать, удалять и читать данные пользователей, но с проверкой прав доступа. В частности, редактировать/удалять/читать можно только если ты авторизован под этим пользователем, либо у тебя есть права админа. Создавать можно без авторизации.

- session-service ходит в user-crud за получением записи по логину и паролю, токены хранит в своей памяти.
- profile-service в session-service для получение идентификатора и роли пользователя, под которым в данный момент мы авторизованы.
- profile-service ходит в user-crud для чтения/редактирования/удаления/создания пользователя пользователя, под которым в данный момент мы авторизованы.

ингресс перенаправляет операции логина/разлогина в session-service, а операции работы с пользователем в profile-service.



Упущения и ограничения
1) Не сделана обработка всех возможных ошибок. Например, при отсутствии данных могут отдаваться 502 вместо 404 и т. п.
2) Хеш считается по md5 (данный подход устарел)
3) Токен считается как md5 от хеша пароля (по-хорошему нужно его формировать специальным образом так, чтобы он был каждый раз уникален)
4) Редактирование не реализовано
5) Удаление не реализовано
6) При авторизации отдается 200, хотя правильнее отдавать 302 с редиректом на указанную в запросе или дефолтную страницу
7) user-crud отдает хеш пароля, что, возможно не очень хорошо, хотя на первый взгляд проблем не вижу
8) функции хеширования (в данном случае md5) используется и в seesion-service и в profile-service, хотя правильнее было бы сделать где-то в одном месте
 


Запуск коллекции postman
В коллекции при авторизации токен прописывается в куки, но при следующем запросе куки обнуляются. Вероятно, можно как-то постман настроить, чтобы куки запоминались. Но в данном случае этого не сделано, так, что нужно руками прописывать куки, которые пришли в ответе на запрос авторизации в последующие запросы.



Инструкция к развертыванию
git clone https://github.com/ATer-Oganisyan/otus-user-crud.git
git clone https://github.com/ATer-Oganisyan/otus-profile.git
git clone https://github.com/ATer-Oganisyan/otus-session.git

cd otus-user-crud 
alias k=kubectl
helm repo add myZql https://charts.bitnami.com/bitnami		
helm install myzql-release myZql/mysql -f kuber/mysql/values.yml
k apply -f ./kuber/config/
k apply -f ./kuber/migrations/
k apply -f ./kuber/app/

cd ../otus-session
k apply -f ./kuber/config
k apply -f ./kuber/app/

cd otus-session
k apply -f ./kuber/config
k apply -f ./kuber/app/

cd ../
k apply -f ingress.yml


Postman
Импортировать Backend for frontend.postman_collection.json в Postman.
